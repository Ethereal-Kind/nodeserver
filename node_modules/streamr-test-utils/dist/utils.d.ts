import { Readable } from "stream";
import { EventEmitter } from "events";
export declare type Event = string | symbol;
/**
 * Collect data of a stream into an array. The array is wrapped in a
 * Promise that resolves when the stream has ended, i.e., event `end` is
 * emitted by stream.
 *
 * @param {ReadableStream} stream to collect data from
 * @returns {Promise<unknown[]>} resolves with array of collected data when
 * stream ends. Rejects if stream encounters `error` event.
 */
export declare const waitForStreamToEnd: (stream: Readable) => Promise<unknown[]>;
/**
 * Wait for an event to be emitted on emitter within timeout.
 *
 * @param emitter emitter of event
 * @param event event to wait for
 * @param timeout amount of time in milliseconds to wait for
 * @returns {Promise<unknown[]>} resolves with event arguments if event occurred
 * within timeout. Otherwise rejected.
 */
export declare const waitForEvent: (emitter: EventEmitter, event: Event, timeout?: number) => Promise<unknown[]>;
/**
 * Run functions and wait for events to be emitted within timeout. Returns a promise created with Promise.all()
 * and waitForEvent() calls. Calls the functions after creating the promise.
 *
 * @param operations function(s) to call
 * @param waitedEvents event(s) to wait for
 * @param timeout amount of time in milliseconds to wait for
 * @returns {Promise<unknown[]>} resolves with event arguments if event occurred
 * within timeout. Otherwise rejected.
 */
export declare const runAndWaitForEvents: (operations: (() => void) | ((() => void)[]), waitedEvents: [emitter: EventEmitter, event: Event] | Array<[emitter: EventEmitter, event: Event]>, timeout?: number) => Promise<unknown[]>;
/**
 * Run functions and wait for one of the events to be emitted within timeout. Returns a promise created with Promise.race()
 * and waitForEvent() calls. Calls the functions after creating the promise.
 *
 * @param operations function(s) to call
 * @param waitedEvents event(s) to wait for
 * @param timeout amount of time in milliseconds to wait for
 * @returns {Promise<unknown[]>} resolves with event arguments if event occurred
 * within timeout. Otherwise rejected.
 */
export declare const runAndRaceEvents: (operations: (() => void) | ((() => void)[]), waitedEvents: [emitter: EventEmitter, event: Event] | Array<[emitter: EventEmitter, event: Event]>, timeout?: number) => Promise<unknown[]>;
/**
 * Wait for a condition to become true by re-evaluating every `retryInterval` milliseconds.
 *
 * @param conditionFn condition to be evaluated; should return boolean or Promise<boolean> and have
 * no side-effects.
 * @param timeout amount of time in milliseconds to wait for
 * @param retryInterval how often, in milliseconds, to re-evaluate condition
 * @param onTimeoutContext evaluated only on timeout. Used to associate human-friendly textual context to error.
 * @returns {Promise<void>} resolves immediately if
 * conditionFn evaluates to true on a retry attempt within timeout. If timeout
 * is reached with conditionFn never evaluating to true, rejects.
 */
export declare const waitForCondition: (conditionFn: () => (boolean | Promise<boolean>), timeout?: number, retryInterval?: number, onTimeoutContext?: (() => string) | undefined) => Promise<void>;
/**
 * Run functions and wait conditions to become true by re-evaluating every `retryInterval` milliseconds. Returns a promise created with Promise.all()
 * and waitForCondition() calls. Calls the functions after creating the promise.
 *
 * @param operations function(s) to call
 * @param conditions condition(s) to be evaluated; condition functions should return boolean or Promise<boolean> and have
 * no side-effects.
 * @param timeout amount of time in milliseconds to wait for
 * @param retryInterval how often, in milliseconds, to re-evaluate condition
 * @param onTimeoutContext evaluated only on timeout. Used to associate human-friendly textual context to error.
 * @returns {Promise<unknown[]>} resolves immediately if
 * conditions evaluate to true on a retry attempt within timeout. If timeout
 * is reached with conditionFn never evaluating to true, rejects.
 */
export declare const runAndWaitForConditions: (operations: (() => void) | ((() => void)[]), conditions: (() => (boolean | Promise<boolean>)) | (() => (boolean | Promise<boolean>))[], timeout?: number, retryInterval?: number, onTimeoutContext?: (() => string) | undefined) => Promise<unknown[]>;
/**
 * Wait for a specific time
 * @param ms time to wait for in milliseconds
 * @returns {Promise<void>} resolves when time has passed
 */
export declare const wait: (ms: number) => Promise<void>;
/**
 * Collect events emitted by an emitter into an array.
 *
 * @param emitter emitter of event(s)
 * @param events list of event types to collect
 * @returns {Array<Event>} array that is pushed to every time emitter emits an event that
 * is defined in `events`
 */
export declare const eventsToArray: (emitter: EventEmitter, events: ReadonlyArray<Event>) => Event[];
/**
 * Collect events emitted by an emitter into an array, including event arguments.
 *
 * @param emitter emitter of event(s)
 * @param events list of event types to collect
 * @returns {Array<[Event, ...any]>} array that is pushed to every time emitter emits an event that
 * is defined in `events`, includes event arguments
 */
export declare const eventsWithArgsToArray: (emitter: EventEmitter, events: ReadonlyArray<Event>) => Array<[Event, ...any]>;
/**
 * Convert a function that has as its last argument a callback of the form
 * (err, result) into a Promise.
 *
 * @param fn should be of format (arg1, arg2, ..., argN, (err, res) => {...})
 * @param args arguments to be passed into fn (before callback)
 * @returns {Promise<T>} rejects with `err` if `err` is "true-ish" in cb.
 * Otherwise resolves with `res`.
 */
export declare const callbackToPromise: <T>(fn: (...innerArgs: any[]) => any, ...args: unknown[]) => Promise<T>;
/**
 * Create a {ReadableStream} out of an array of items. Any {Error} items will
 * be emitted as error events instead of pushed to stream.
 * @param args an array of items
 * @returns {ReadableStream}
 */
export declare const toReadableStream: (...args: unknown[]) => Readable;
