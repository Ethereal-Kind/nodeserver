/**
 * Wrapper around PushPipeline specific to StreamMessages.
 * Subscriptions are MessageStreams.
 * Not all MessageStreams are Subscriptions.
 */
import { PushPipeline, PipelineTransform } from '../utils/Pipeline';
import { Context } from '../utils/Context';
import { StreamMessage } from 'streamr-client-protocol';
import * as G from '../utils/GeneratorUtils';
export declare type MessageStreamOnMessage<T, R = unknown> = (msg: T, streamMessage: StreamMessage<T>) => R | Promise<R>;
export declare type MessageStreamOptions = {
    bufferSize?: number;
    name?: string;
};
export declare class MessageStream<T = unknown, InType = StreamMessage<T>, OutType extends StreamMessage<T> | unknown = InType> extends PushPipeline<InType, OutType> {
    constructor(context: Context, { bufferSize, name }?: MessageStreamOptions);
    /**
     * Attach a legacy onMessage handler and consume if necessary.
     * onMessage is passed parsed content as first arument, and streamMessage as second argument.
     */
    useLegacyOnMessageHandler(onMessage?: MessageStreamOnMessage<T>): this;
    collectContent(n?: number): Promise<any[]>;
    pipe<NewOutType>(fn: PipelineTransform<OutType, NewOutType>): MessageStream<T, InType, NewOutType>;
    pipeBefore(fn: PipelineTransform<InType, InType>): MessageStream<T, InType, OutType>;
    map<NewOutType>(fn: G.GeneratorMap<OutType, NewOutType>): MessageStream<T, InType, NewOutType>;
    filterBefore(fn: G.GeneratorFilter<InType>): MessageStream<T, InType, OutType>;
    filter(fn: G.GeneratorFilter<OutType>): MessageStream<T, InType, OutType>;
    forEach(fn: G.GeneratorForEach<OutType>): MessageStream<T, InType, OutType>;
    forEachBefore(fn: G.GeneratorForEach<InType>): MessageStream<T, InType, OutType>;
}
