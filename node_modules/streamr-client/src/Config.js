"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULTS = exports.Config = void 0;
/**
 * New Brubeck Configuration.
 * Old Config in ConfigBase.
 * TODO: Disolve ConfigBase.
 */
require("reflect-metadata");
const ConfigBase_1 = __importDefault(require("./ConfigBase"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const merge_1 = __importDefault(require("lodash/merge"));
/**
 * DI Injection tokens for pieces of config.
 * tsyringe needs a concrete value to use as the injection token.
 * In the case of interfaces & types, these have no runtime value
 * so we have to introduce some token to use for their injection.
 * These symbols represent subsections of the full config.
 *
 * For example:
 * config.ethereum can be injected with a token like: @inject(Config.Ethereum)
 */
const BrubeckConfigInjection = {
    Root: Symbol('Config.Root'),
    Auth: Symbol('Config.Auth'),
    Ethereum: Symbol('Config.Ethereum'),
    Network: Symbol('Config.Network'),
    Connection: Symbol('Config.Connection'),
    Subscribe: Symbol('Config.Subscribe'),
    Publish: Symbol('Config.Publish'),
    Cache: Symbol('Config.Cache'),
    StorageNodeRegistry: Symbol('Config.StorageNodeRegistry'),
    Encryption: Symbol('Config.Encryption'),
};
exports.Config = BrubeckConfigInjection;
__exportStar(require("./ConfigBase"), exports);
// TODO: Production values
const BRUBECK_CLIENT_DEFAULTS = {
    debug: {
        inspectOpts: {
            depth: 5,
            maxStringLength: 512
        }
    },
    network: {
        trackers: {
            contractAddress: '0xab9BEb0e8B106078c953CcAB4D6bF9142BeF854d'
        },
        acceptProxyConnections: false
    },
};
exports.DEFAULTS = BRUBECK_CLIENT_DEFAULTS;
function BrubeckConfig(config) {
    var _a, _b;
    const clonedConfig = (0, cloneDeep_1.default)(config);
    const defaults = (0, cloneDeep_1.default)(BRUBECK_CLIENT_DEFAULTS);
    const userConfig = (0, ConfigBase_1.default)(clonedConfig);
    const result = {
        ...defaults,
        ...userConfig,
        network: {
            ...(0, merge_1.default)(defaults.network || {}, clonedConfig.network),
            trackers: (_b = (_a = clonedConfig.network) === null || _a === void 0 ? void 0 : _a.trackers) !== null && _b !== void 0 ? _b : defaults.network.trackers,
        },
        debug: (0, merge_1.default)(defaults.debug || {}, clonedConfig.debug),
    };
    return result;
}
exports.default = BrubeckConfig;
//# sourceMappingURL=Config.js.map