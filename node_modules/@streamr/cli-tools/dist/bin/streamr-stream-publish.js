#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("../src/logLevel");
const stream_1 = require("stream");
const streamr_test_utils_1 = require("streamr-test-utils");
const event_stream_1 = __importDefault(require("event-stream"));
const command_1 = require("../src/command");
const publishStream = (stream, partitionKeyField, client) => {
    const writable = new stream_1.Writable({
        objectMode: true,
        write: (data, _, done) => {
            let json = null;
            // ignore newlines, etc
            if (!data || String(data).trim() === '') {
                done();
                return;
            }
            try {
                json = JSON.parse(data);
            }
            catch (e) {
                console.error(data.toString());
                done(e);
                return;
            }
            const partitionKey = (partitionKeyField !== undefined) ? json[partitionKeyField] : undefined;
            client.publish(stream, json, Date.now(), partitionKey).then(() => done(), (err) => done(err));
        }
    });
    return writable;
};
(0, command_1.createClientCommand)(async (client, streamId, options) => {
    const ps = publishStream(streamId, options.partitionKeyField, client);
    return new Promise((resolve, reject) => {
        process.stdin
            .pipe(event_stream_1.default.split())
            .pipe(ps)
            .once('finish', async () => {
            // We need to wait some time because the client.publish() may resolve the promise
            // before the node has propagated the message. That may happend if the node
            // has not yet connected to Tracker when client.publish() is called. In that case
            // the message is put to the propagation queue (activeTaskStore.add call in
            // network Propagation.ts:59) and the client.publish() promise resolves immeditatelly.
            // TODO Remove this wait when NET-604 has been resolved
            await (0, streamr_test_utils_1.wait)(2000);
            resolve(undefined);
        })
            .once('error', (err) => reject(err));
    });
})
    .arguments('<streamId>')
    .description('publish to a stream by reading JSON messages from stdin line-by-line')
    .option('-k, --partition-key-field <string>', 'field name in each message to use for assigning the message to a stream partition')
    .parseAsync();
//# sourceMappingURL=streamr-stream-publish.js.map