"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClientCommand = exports.createCommand = void 0;
const commander_1 = require("commander");
const package_json_1 = __importDefault(require("../package.json"));
const client_1 = require("./client");
const createCommand = () => {
    return new commander_1.Command()
        .version(package_json_1.default.version)
        .showHelpAfterError()
        .allowExcessArguments(false);
};
exports.createCommand = createCommand;
const createClientCommand = (action, opts = {
    autoDestroyClient: true,
    clientOptionsFactory: () => ({})
}) => {
    return (0, exports.createCommand)()
        .option('--private-key <key>', 'use an Ethereum private key to authenticate')
        .option('--config <file>', 'read connection and authentication settings from a config file')
        .option('--dev', 'use pre-defined development environment')
        .action(async (...args) => {
        const commandLineOptions = args[args.length - 1].opts();
        try {
            const client = (0, client_1.createClient)(commandLineOptions, opts.clientOptionsFactory(commandLineOptions));
            try {
                await action(...[client].concat(args));
            }
            finally {
                if (opts.autoDestroyClient) {
                    await client.destroy();
                }
            }
        }
        catch (e) {
            console.error(e);
            process.exit(1);
        }
    });
};
exports.createClientCommand = createClientCommand;
//# sourceMappingURL=command.js.map